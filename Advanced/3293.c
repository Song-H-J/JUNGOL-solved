// 2024. 07. 24. 
// 송현준

#include <stdio.h>

char op[7][4] = {"?", "~", "&", "|", "^", "<<", ">>"};
 
int main(){
    printf("%s\n",     op[2]);				 /// (1)
	/*
	if(a?1){}
	a가 홀수라면 1, 아니라면 0
	홀수라면 마지막 비트가 1 ex) 3 = 0011
	1의 비트는 0001
	양쪽 끝 비트가 모두 1이면 홀수
	양쪽 끝 비트가 다르면 짝수
	양쪽 끝 비트가 모두 0인 경우는 없음. 한쪽이 1이기 때문.
	if의 조건 판단은 끝 비트 하나를 체크한다.
	즉 & 연산을 사용하면 양쪽 끝 비트가 1인 경우에만 끝 비트가 1이 된다.
	*/
    printf("%s%s\n",   op[1], op[2]);		 /// (2)
	/*
	if(?a?1){}
	a가 짝수라면 1, 아니라면 0
	짝수라면 마지막 비트가 0 ex) 6 = 0110
	1의 비트는 0001
	짝수의 비트를 반전시키면 끝 비트가 1
	즉 짝수의 비트를 반전시킨 후 (1)의 & 연산을 사용하면
	짝수를 검출 가능하다.
	*/
    printf("%s\n",     op[5]);				 /// (3)
	/*
	result = a ? k;
	result는 a * 2의 k 제곱
	a<<1을 하면 모든 비트가 왼쪽으로 한 칸 이동
	왼쪽으로 한 칸 이동 == 2가 곱해졌다.
	ex) 2 = 0010 -> 0100 = 4
	즉 a<<1을 n번 수행하면 2의 n승만큼 곱해졌다.
	따라서 << 연산자를 사용하면 올바른 result가 출력된다.
	*/
    printf("%s%s%s\n", op[6], op[2], op[5]); /// (4)
	/*
	p = a ? k;
	r = a ? ((1 ? k) - 1);
	p는 a를 2의 k승으로 나눈 몫
	r은 a를 2의 k으로 나눈 나머지
	(3)과 동일한 원리로 a>>k는 a를 2의 k승만큼 나눈 값이고
	그 값은 정수이므로 몫 p다.
	우선 1<<k는 2의 k승이고 그 비트 구조는 하나의 1비트만을 가진다.
	이때 끝자리 비트는 1비트를 가질 수 없다.
	ex) 2^2 = 4 = 0100 , 2^3 = 8 = 1000
	이 구조에서 -1을 해주면 1비트를 가진 비트가 0이 되고
	그 비트의 아랫단은 전부 1이 된다.
	ex) 4 - 1 = 3 = 0011, 8 - 1 = 7 = 0111
	이 비트 구조를 원본 숫자와의 & 연산에 활용하면 그 결과는 다음과 같다.
	우선 원래 1비트가 있던 곳 윗단의 비트들은
	& 연산으로 인해 모두 0이 된다.
	즉 2^k 이상의 값을 가질 수 있는 비트들은 모두 0이 된다.
	결과적으로 & 연산의 결과로 나오는 값들은 무조건
	2^k보다 작을 수 밖에 없다.
	ㄴ 나머지의 개념과 똑같다.
	그럼 이제 원본 숫자에서 2^k보다 작은 값을 추출해내야 하는데
	(1<<k-1)로 인해 2^k의 1비트보다 작은 비트들은 모두 1이 됐으므로,
	비교해서 양쪽이 모두 1인 것만 걸러낸다면
	원본 숫자를 2^k로 나눈 나머지 r을 찾을 수 있다.
	따라서 답은
	p = a >> k;
	r = a & ((1 << k) - 1);
	*/
	printf("%s%s%s\n", op[4], op[4], op[4]); /// (5)
	/*
	a = a ? b;
	b = a ? b;
	a = a ? b;
	a와 b의 값을 바꿔라
	우선 코드를 잘 살펴보면
	1. a에 특정한 값이 들어갔다. 이제 a = s_value
	2. b에 특정한 값과 b를 비트 연산한 값이 들어갔다.
		이때 코드 구조 상 대입연산자 우측의 b = b_value를 지니고
		대입연산자 좌측의 b는 a_value를 지녀야만 한다.
	3. a에 특정한 값과 b를 비트 연산한 값이 들어갔다.
		이때 b = a_value가 들어가이었야만 하며
		a에는 a_value와 s_value를 비트 연산한 값이 들어가야 하고
		그 값은 b_value여야만 한다.
	따라서 s_value와 비트 연산하면 b_value는 a_value로
	a_value는 b_value로 바뀐다는 것을 알 수 있다.
	그럼 s_value에는 a와 b의 정보가 모두 들어가야 함을 알 수 있다.
	따라서 ^ 연산을 사용한다.
	^ 연산을 사용하면 a, b의 비트 중
	같은 비트는 0이 되고, 다른 비트들은 1이 된다.
	즉 차이가 있는 비트들은 1, 차이가 없는 비트들은 0이 되었으므로
	이제 s_value = a^b는 a와 b의 차이를 담고 있는 비트가 되었다.
	s_value에 a_value를 ^ 연산하면 결과는 다음과 같다.
	1. a와 b가 차이가 나는데, 1
		a의 비트가 1이라면 그에 대응하는 b의 비트는 0일 것이다.
	2. a와 b가 차이가 나는데, 1
		a의 비트가 0이라면 그에 대응하는 b의 비트는 1일 것이다.
	3. a와 b가 차이가 없는데, 0
		a의 비트가 0이라면 그에 대응하는 b의 비트도 0일 것이다.
	4. a와 b가 차이가 없는데, 0
		a의 비트가 1이라면 그에 대응하는 b의 비트도 1일 것이다.
	즉 비트 표현식으로 풀어보면
	1. 1 ? 1 = 0
	2. 1 ? 0 = 1
	3. 0 ? 0 = 0
	4. 0 ? 1 = 1
	표현식을 보면 둘이 같은 경우에는 0이, 다른 경우에는 1이 나오는
	비트 연산이 필요함을 알 수 있다.
	즉 ^ 연산을 사용해야 함이 증명되었다.
	따라서 이 문제의 연산자는 모두 ^다.
	*/
	printf("%s%s\n",   op[6], op[2]);		 /// (6)
	/*
	result = (a ? k) ? 1;
	a의 k번째(2의 k제곱 ​자리) 비트가 0인지 1인지 알아보고자 한다.
	즉 a의 k번째 비트가 1이면 1, 0이면 0을 원한다.
	후방의 ? 1을 보면 1과 비트 연산을 하라는 뜻이고
	앞서 (1),(2)에서 보았듯이 1과 비교 대상이 될 비트가
	맨 끝에 오게 한 뒤 그 비트를 참일 때 1, 거짓일 때 0이 되게 맞추고
	& 비트 연산을 수행하면 참이면 1, 거짓이면 0이 나온다.
	즉 맨 끝의 연산자는 &일 것이다.
	그렇다면 a?k의 결과로 a의 k번째 비트를 맨 끝으로 보내야한다.
	NOTE
	2^k의 승의 비트는 k번째만 1이다.
	즉 k번째 비트의 위치 = 1<<k에서 1이 위치한 장소가 된다.
	그렇다면 반대로 a>>k 연산을 수행한다면
	a의 k번째 비트는 맨 밑 비트로 내려오게 된다.
	이제 그 비트가 1이면 참, 0이면 거짓이니까
	굳이 반전을 해줄 필요없이 &1 연산을 하면 올바른 result를 얻을 수 있다.
	따라서 답은 >> , &
	*/
	printf("%s%s%s\n", op[2], op[1], op[5]); /// (7)
	/*
	a = a ? (?(1 ? k));
	a의 k번째(2의 k제곱 ​자리) 비트만 0이면 1로, 1이면 0으로 바꾸고자 한다.
	쉽게 생각해보자
	우선 우리는 2의 k제곱 자리 비트에 대한 정보다 필요하다.
	그러므로 1<<k 일 것임을 간단하게 알 수 있다.
	1<<k 앞에 괄호로 싸인 한 개의 연산자가 붙었는데
	이것도 논리적으로 ~ 연산자임을 추측할 수 있다.
	그렇다면 만약 ~ 연산자라면 어떤 일이 일어날까.
	2의 k승 비트는 1이 1개고 나머지가 0이다.
	반전시키면 비트 0이 1개고, 나머지가 1이 될 것이다.
	이때 0이 위치한 위치가 바로 2의 k제곱 자리 비트가 될 것이고.
	a로 따지자면 a의 k번째 비트가 위치한 곳이 된다.
	그렇다면 양쪽 모두가 1일 때 1을 출력하게 한다면?
	a의 0비트들은 모두 0비트로, a의 1비트들은 모두 1비트로 그대로일 것이다.
	어디만 빼고?
	바로 유일하게 0이 있는 k번째 비트만을 빼고 말이다.
	1<<k에서 이미 0으로 k번째 비트를 가지고 있으니
	a의 k번째 비트만 무조건 0이 된다.
	따라서 답은 &, <<이 된다.
	*/
	printf("%s%s\n",   op[4], op[5]);		 /// (8)
	/*
	a = a ? (1 ? k);
	a의 k번째(2의 k제곱 ​자리) 비트만 0이면 1로, 1이면 0으로 바꾸고자 한다.
	(7)과 비슷한 문제지만 비트 반전을 요구한다.
	우선 (7)과 같은 논리로 1<<k 일 것임을 알 수 있다.
	비트 반전을 시키지 않으면 1<<k의 비트는
	0000010000000 이런 식이다.
	이 1이 위치의 a 비트만을 반전시켜야 한다.
	우선 나머지 비트가 모두 0인것에서 힌트를 얻을 수 있다.
	나머지 비트가 모두 0이라면 k번째 비트를 제외하고 
	비트 연산의 결과로
	0?0 = 0
	0?1 = 1
	의 결과가 나와주면 된다.
	이것이 가능한 연산자는 2개다.
	다를 때 1, 같을 때 0인 ^
	양쪽 중 하나라도 1이면 1인 |
	그런데 이제 k번째를 고려해보면
	1?0 = 1
	1?1 = 0
	이런 비트 연산 결과가 요구된다.
	2개 중 이 결과값을 만들 수 있는 것은 ^다.
	따라서 ^, <<가 정답이다.
	*/
	printf("%s\n",	   op[2]);				 /// (9)
	/*
	result = a ? (a - 1);
	if( a > 0 && result==0) 2의 제곱수다.
	a가 2의 제곱수인지 판별하고자 한다.
	앞선 NOTE에서 제곱수 비트의 성질에 대해 설명했다.
	즉 a가 제곱수라면
	a = 0100
	a-1 = 0011
	의 비트 구조를 가질 것이다.
	result의 결과가 0일때가 제곱수임으로
	a?(a-1) 의 비트 연산 결과는 0이어야 한다.
	위 비트 구조를 보면 쉽게 답을 알 수 있다.
	제곱수는 k승만 1이고
	제곱수 -1은 k승 아래로 전부 1이고 나머지가 0이다.
	즉 제곱수라면 제곱수-1과 & 연산을 수행하면 
	무조건 0이 나오게 된다.
	따라서 & 연산이 정답이다.
	*/
	printf("%s%s\n",   op[4], op[2]);		 /// (10)
	/*
	bit = a ? b;
	result = bit ? (bit -1);
    if(result==0) 서로 다른 비트가 1개 이하다. 참  ​
	a와 b의 같은 자리 비트를 비교한 결과
	서로 다른 비트가 1개 이하인지 알아보고자 한다.
	2번째 줄과 3번째 줄을 보면 쉽게 풀 수 있다.
	앞서 제곱수인지 판별하는 문제와 조건이 완벽하게 똑같다.
	즉 bit가 2의 제곱수면 문제가 해결된다.
	따라서 두번째 연산자는 &일 것이다.
	그럼 이제 bit = a?b의 연산결과를 제곱수 형태의 비트로 만들면 된다.
	1이 한 개만 존재해야 하고, 나머지가 모두 0이 나오는
	연산 수행이 필요하다.
	서로 다른 비트가 1개 이하라는 것은
	서로 차이가 나는게 1개 이하라고 볼 수 있다.
	그렇다면 같은 것은 0, 다른 것은 1이 나오는 ^ 연산을 수행하면
	조건을 만족할 시 1비트의 갯수가 1 or 0개가 나온다.
	1개라면 제곱수 조건을 만족하기에 통과.
	0개라면, 즉 차이가 없다면 bit = 0000, bit -1 = 0000
	되서 자동적으로 result도 0이 된다.
	따라서 답은 ^, &가 된다.
	*/
	return 0;
}